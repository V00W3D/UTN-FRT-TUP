 EL CONCEPTO DE CICLO DE VIDA DE UN PROYECTO 
Como pudiera esperarse, las organizaciones pequeñas de proceso de datos tienden a ser relativamente informales: los proyectos de desarrollo de sistemas na-cen de conversaciones entre el usuario y el administrador del proyecto (que puede ser a la vez el analista, el programador, el operario y el conserje), y el proyecto pro-cede desde el análisis hasta el diseño e implantación sin mayor alboroto. 
Sin embargo, en las organizaciones más grandes, las cosas se llevan a cabo de manera mucho más formal. La comunicación entre los usuarios, la administra-ción y el equipo del proyecto suele ser por escrito, y todo mundo entiende que el proyecto pasará por diversas fases antes de completarse. Aun así, es sorprendente ver la gran diferencia entre las maneras en que dos administradores afrontan sus respectivos proyectos. De hecho, a menudo se deja a discreción del administrador determinar las fases y actividades de su proyecto, y cómo se llevarán a cabo. Recientemente, sin embargo, ha empezado a cambiar el enfoque que se le da al desarrollo de sistemas. Cada vez son más las organizaciones grandes y peque-ñas que están adoptando un ciclo de vida uniforme y único para sus proyectos. Esto a veces se conoce como el plan del proyecto, la metodología del desarrollo del siste-ma c, simplemente, "la forma en la que hacemos las cosas aquí". El manual del ci-clo de vida del proyecto suele ser un libro tan voluminoso como el compendio de normas, que yace (usualmente sin ser leído) sobre el escritorio de todo analista y Esto suena como si la anarquía prevaleciera en la mayoría de las organizaciones de proceso electrónico de datos. Sin embargo, hay dos situaciones comunes que llevan a este enfoque indivi-dualista aun en la organización más ejemplar: La organización altamente descentralizada, donde cada departamento tiene su grupo de proceso electrónico de datos con sus propias normas locales y el periodo de varios años tras de que el último "ciclo de vida oficial del proyecto se juzgara inú-til y se descartara. EL CICLO DE VIDA DEL PROYECTO 
programador. Ese manual ofrece un procedimiento común a seguir para desarrollar un sistema computacional que puede orientar a cualquier miembro de la organiza-ción de desarrollo de sistemas. 
El enfoque puede ser casero o, como alternativa, pudiera ser que la organiza-ciór para el desarrollo de sistemas decida comprar un paquete de administración de proyectos y ajustarlo a las necesidades de la compañía. Parece obvio que, aparte ce dare empleo a las personas que crean los manuales de ciclo de vida de los pro-yectos (y a aquellos que escriben libros de texto al respecto), es conveniente la me-todología del proyecto. ¿De qué sirve entonces tener un ciclo de vida de un proyecto? Existen tres objetivos principales: 
Definir las actividades a llevarse a cabo en un proyecto de desarrollo de sistemas. Lograr congruencia entre la multitud de proyectos de desarrollo de siste-mas en una misma organización. Proporcionar puntos de control y revisión administrativos de las decisio-nes sobre continuar o no con un proyecto. 
El primer objetivo es de particular importancia en una organización grande donde constantemente está ingresando personal nuevo a los puestos de administra-ción de proyectos. El administrador novato pudiera no tomar en cuenta o subestimar la importancia de lases clave del proyecto si se basa sólo en su intuición. De hecho, pudiera suceder que los programadores y analistas de bajo rango no entiendan dón-de y cómo encajan sus esfuerzos individuales en el proyecto global, a menos que se les dé una descripción adecuada de todas las fases del proyecto. 
El segundo objetivo también es importante en una organización grande. Para los niveles más altos de la administración pudiera ser bastante confuso seguir la pis-ta de cientos de proyectos diferentes, cada uno de los cuales se lleva a cabo de dis-tinta manera. Por ejemplo, si el proyecto A define la actividad de análisis de sistemas de diferente forma que el proyecto B y el B no incluye una fase de diseño, ¿cómc puede darse cuenta el administrador de segundo o tercer nivel de cuál pro-yecto se está rezagando y cuál continúa según lo previsto? Existen varios ce estos paquetes en el mercado, que cuestan entre $ , y $ , dólares estadounidenses o su equivalente en moneda nacional), o más. Algunos de los ejemplos más co-nocidos son Spectrum (de Spectrum International Corp.), SDM- (de AGS Software), y Method/ (de Arthur Ancersen). No comentaré acerca de ningúr paquete de administración de proyectos en particular; sólc le sugiero que tenga en mente los conceptos presentados en este libro si su organi-zación utiliza un paquete obtenido en el mercado. Miler en [Miller, , señala que éste es un fenómeno comúnmente observado; de hecho, lo presenta como una "hipótesis" general aplicable a todos los sistemas en activo:
EL CICLO DE VIDA DEL PROYECTO 

El tercer objetivo de un ciclo de vida de proyecto normal se refiere a la necesi-dad de la administración de controlar un proyecto. En los proyectos triviales, el úni co punto de revisión probablemente esté al final del proyecto: ¿se concluyó a tiempo y dentro de los márgenes del presupuesto acordado? (o, más simple aún, ¿se con-cluyó siquiera?) ¿Y cumplió con los requisitos del usuario? Pero, para proyectos más grandes, debería contarse con varios puntos intermedios de revisión, que per-mitieran determinar si el proyecto se estuviera retrasando o si fueran necesarios re-cursos adicionales. Además, el usuario inteligente también necesitará puntos de revisión en diversas etapas del proyecto para que pueda determinar si quiere conti-nuar financiándolo. Dicho todo esto, no queda más que subrayar que el ciclo de vida del proyecto definitivamente no está a cargo del proyecto; no le evitará al administrador del pro-yecto la difícil labor de tomar decisiones, sopesar alternativas, librar batallas políti-cas, negociar con usuarios recalcitrantes, animar a programadores deprimidos, ni ninguna de las demás tribulaciones relacionadas con los proyectos. El administrador del proyecto todavía tiene que administrar, en todo el sentido de la palabra. La úni ca ayuda que puede proporcionar el ciclo de vida del proyecto es que puede organi-zar las actividades del administrador, aumentando la probabilidad de que se aborden los problemas pertinentes en el momento adecuado. EL CICLO DE VIDA DEL PROYECTO CLASICO 
El tipo de ciclo de vida de proyecto que se usa actualmente en la mayoría de las organizaciones difiere de aquel al que estaremos dedicando la mayor parte de nuestra atención en la parte III. En la figura se muestra el ciclo de vida clásico o convencional. Cada proyecto atraviesa por algún tipo de análisis, diseño e implanta-ción, aunque no se haga exactamente como se muestra en el diagrama. El ciclo de vida de proyecto utilizado, por ejemplo, en la organización de usted, pudiera diferir del que se muestra en la figura en una o en todas las formas siguientes: 
HIPOTESIS - : Los componentes de un sistema ncapaces de aso-ciarse, o que carecen de la experiencia que haya formado tales asociaciones, deben funcionar de acuerdo con una programación ri-gida o con reglas de operación altamente estandarizadas. Se sigue que si la rotación de los componentes rebasa el ritmo con que se están desarrollando las asociaciones necesarias para su operación, aumenta la rigidez en la programación. De hecho, los procedimientos de la mayor parte de los proyectos de proceso de datos son tales que existe sólo un punto de control desde el cual el usuario tiene una manera obvia y limpia de arrepentirse: al final de la fase de encuesta o del estudio de factibilidad. En teoría, sin embargo, el usuario debería tener la oportunidad de cancelar un proyecto de proceso de datos al final de cual-quier fase si piensa que está desperdiciando su dinero.
Las fases de exploración y análisis pudieran juntarse en una sola (sobre todo en organizaciones en las cuales se considera factible desde el inicio cualquier cosa que quiera el usuario). 
Puede no haber fase de estudio de hardware si se cree que cualquier sis-tema nuevo pudiera instalarse con las computadoras existentes sin cau-sar mayor problema operacional. 
Las fases de diseño preliminar y de diseño de detalles pudieran juntarse en una sola llamada simplemente de diseño. 
Diversas fases de prueba pueden juntarse en una sola; de hecho, podrían incluirse con la codificación. 
De aquí que el ciclo de vida del proyecto en una organización sola puede tener cinco fases o siete o doce, pero seguir siendo todavía de tipo clásico. 
¿Qué es lo que realmente caracteriza el ciclo de vida de un proyecto como clá-sico? Se distinguen dos aspectos: una fuerte tendencia a la implantación ascenden-te del sistema y la insistencia en la progresión lineal y secuencial de una fase a la siguiente. Implantación ascendente 
El uso de la implantación ascendente es una de las grandes debilidades del ci-clo de vida de los proyectos clásicos. Como se podrá ver en la figura (a), se es-pera que los programadores lleven a cabo primero sus pruebas modulares, luego las pruebas del subsistema, y finalmente las pruebas del sistema mismo. Este enfoque también se conoce como el ciclo de vida de cascada, y está basado en el diagrama presentado originalmente en [Royce, , y popularizado posteriormente por Barry Boehm [Boehm, ]. Se muestra en la figura (b). 
No está claro de dónde surgió originalmente este enfoque, pero pudiera haber-se tomado de las líneas de montaje de las industrias manufactureras. La implanta-ción ascendente es buena para el montaje de automóviles en línea, jpero sólo después de que el prototipo esté completamente libre de fallas/ Desafortunaca-mente, muchas organizaciones que desarrollan sistemas todavía producen sistemas únicos, para lo cual el enfoque ascendente presenta un gran número de dificultades serias: Muchos creen que el enfoque ascendente pudiera provenir de la incustria computacional del hard-ware porque muchos de os programadores y administradores de programación de los años y eran ingenieros eléctrónicos que habían tenido que ver previamente con el desarro lo de hardware.
Nada está hecho hasta que todo esté terminado. Por eso, si el proyecto se arasa y la fecha límite cae precisamente en medio del proceso de prueba del sistema, no habrá nada que mostrarle al usuario más que una erorme pila de listados de programas, los cuales, vistos en su totalidad, nc le ofrecen nada de valor. 
Las fallas más triviales se encuentran al comienzo del periodo de prueba y las más graves al final. Esto es casi una tautología: las pruebas modula. res dejan al descubierto fallas relativamente simples dentro de los módu-los individuales. Las pruebas del sistema, por otra parte, descubren eriores grandes de interfaz entre subsistemas. La cuestión es que los errores de interfaz no son lo que el programador desea descubrir al final de ur proyecto de desarrollo; tales fallas pueden obligar a la recodifica-ción de un gran número de módulos, y pueden tener un impacto devasta-dor sobre el calendario, justo en un momento en el cual es probable que toco el mundo esté algo cansado y molesto tras haber trabajado duro du-rarte tantos meses. 
La elimiración de fallas suele ser extremadamente dificil durante las últi-mas etapas de prueba del sistema. Nótese que se puede distinguir entre pruebas y eliminación de fallas. La eliminación de fallas es el arte de descubrir dónde está la falla (y subsecuentemente cómo arreglaria) des-pués de que el proceso de prueba ha determinado que la falla de hecho existe Cuando la falla se descubre durante la fase de prueba del sistema en un proyecto ascendente, a menudo suele ser extremadamente difícil determinar cuál módulo la contiene; pudiera tratarse de cualquiera de los cientos (o miles) de módulos que se han combinado por primera vez. Lo-calizar ura falla a menudo es como hallar una aguja en un pajar. 
La neces dad de prueba con la computadora aumenta exponencialmente durante las etapas finales de prueba. Para ser más específicos, el admi-nistrador del proyecto a menudo descubre que necesita una gran cantidad ce horas-máquina para probar el sistema; tal vez horas de labor ininte-rrumpida diaria. Dado que suele ser difícil obtener tanto tiempo de uso de la computadora, el proyecto suele retrasarse mucho. Progresión Secuencial 
La segunda debilidad más importante del ciclo de vida de un proyecto clásico es suns stencia en que las fases se sucedan secuencialmente. Querer esto es una tendencia natu al humana: deseamos decir que hemos terminado la fase de análisis Estoy convencido de que aquí se aplica otra más de las leyes de Murphy: Entre más grande y más crílico sea el proyecto, más probable es que la fecha límite coincida con el proceso de fin de año o a guna ctra crisis organizacional que monopoliza todo el tiempo de computadora disponible.
del sistema y que nunca tendremos que volver a preocuparnos por ella. De hecho, muchas organizaciones formalizan esto con un ritual conocido como "congelar" la especificación o congelar el documento de diseño. 
El único problema que trae consigo este deseo de progreso ordenado es que no es nada realista. En lo particular, el enfoque secuencial no permite el tratamien-to de fenómencs reales como los relacionados con el personal, la política de la compañía, o a economía. Por ejemplo, la persona que hizo el trabajo, el analista o el diseñador, pudieron haber cometido un error y haber elaborado un producto con fallas. De hecho, como humanos, rara vez atinamos a hacer bien un trabajo al pri-mer intento, pero se suelen hacer repetidas mejoras del trabajo imperfecto. Tam-bién pudiera ser que la persona que revisa el trabajo o, como caso particular, el usuario que revisa el trabajo del analista del sistema pudiera haber cometido un error. O tal vez el encargado de llevar a cabo la labor asociada con cada fase no haya tenido tiempc suficiente para terminar, pero no quiera admitirlo. Esta es una manera amable de decir que, en la mayoría de los proyectos complejos, la labor de análisis, de diseño y de prueba concluye cuando alguien decide que se ha agotado el tiempo, no cuando se quisiera. 
Comúnmente surgen otros problemas asociados con el ciclo de vida del proyec-to clásico o secuencial: durante los meses (o años) que toma desarrollar el sistema, el usuario pudiera cambiar de parecer respecto a lo que debe hacer el sistema. Du-rante el perícdo que transcurre para desarrollar el sistema, pueden cambiar ciertos aspectos cel ambiente del usuario (por ejemplo, la economía, la competencia, los re-glamentos gubernamentales que afectan a las actividades del usuaric). 
Una característica adicional del ciclo de vida del proyecto clásico es que se apoya en técnicas anticuadas. Es decir, tiende a ignorar el uso del análisis estructu-rado la programación estructurada, o cualquier otra técnica moderna de desarrollo de sistemas. Pero el hecho de que el ciclo de vida clásico ignore estas técnicas no significa que el administrador del proyecto no pueda utilizarlas. Desafortunadamen-te, muchos programadores, analistas y jefes de proyecto sienten que el ciclo de vida del proyecto es un mandato de la administración de alto nivel; y si la administración no dice nada al respecto del uso de la programación estructurada, entonces creen que no están obligados a utilizar métodos no clásicos. EL CICLO DE VIDA SEMIESTRUCTURADO 
Los comentarios de la sección anterior pueden hacer que parezca que la ma-yoría de las organzaciones de proceso de datos todavía viven en la Edad Media. De hecho, esto es injusto: no todas las organizaciones utilizan el ciclo de vida clási co. Desde fines de los años y principios de los , ha crecido la tendencia a re-conccer al diseño estructurado, la programación estructurada y la implantación descendente como parte del ciclo de vida del proyecto. Este reconocimiento ha lle- Resumiremos estas écnicas modernas de desarrol o en el capítulo vado al ciclo de vida del proyecto semiestructurado que se muestra en la figura Se muestran dos detalles obvios no presentes en el enfoque clásico: La secuencia ascendente de codificación, la prueba de módulos y prueba del sistema se reemplazan por una implantación de arriba hacia abajo, que es un enfoque en el cual los módulos de alto nivel se codifican y prueban primero, seguidos por los de bajo nivel, más detallados. Tam-bién hay fuertes indicios de que la programación estructurada debe usar-se como método para codificar el sistema. El diseño clásico se reemplaza por el diseño estructurado, que es un en-foque de diseño formal de sistemas tratado en textos tales como [Yourdon y Constantine, ] y [Page-Jones, ]. 
Aparte de estas diferencias obvias, hay algunos detalles sutiles acerca del ci-clo de vida modificado. Por ejemplo, considere que la implantación descendente sig-nifica que se pondrán en ejecución paralelamente parte de la codificación y de las pruebas. Esto difiere mucho de las fases secuenciales que vimos en el ciclo de vida clásico. En lo particular, puede darse una retroalimentación entre la codificación, la prueba y la eliminación de las fallas. Cuando el programador prueba la versión de alto nivel del sistema, a veces se le puede llegar a oir exclamar: "¡Vaya, no tenía idea de que la instrucción FRAMMIS de doble precisión funcionara de esa manera!". Desde luego, se puede tener la seguridad de que en el futuro usará de manera muy diferente esta instrucción. 
Tal vez sea aún más importante el hecho de que la implantación descendente pone en tentación a los ejecutores del sistema (y a los analistas si aún no han aban-conado el proyecto) de no hablar con los usuarios sino hasta después de haberse congelado las especificaciones. Por eso, es posible que el usuario señale errcres o malentendidos en la especificación, o incluso pudiera expresar el deseo de cambiar-la y, si la conversación se da directamente entre el usuario y el que implanta, la mo-dificación pudiera hacerse antes de que el administrador del proyecto se dé cuenta siquiera. En resumen, a menudo la implantación descendente ofrece retroalimenta-ción entre el procesc de implantación y el de análisis, aunque esto no se muestre específicamente en la Figura , y aunque el usuario y el administrador del proyecto de proceso de datos pudieran negar que esté sucediendo. 
Como último punto a tratar acerca del ciclo de vida semiestructuraco, tenemos que una gran parte del trabajo que se realiza bajo el nombre de "diseño estructura-do" es en realidad un esfuerzo manual para enmendar especificaciones erróneas. Esto se puede apreciar en la figura , que muestra los detalles del diseño estruc-turado. (Nótese que esta Figura consiste en los detalles del proceso de la figu-ra En la figura , la actividad (con el título de CODIFICAR LA ESPECIFICA-CION FUNCIONAL) representa la labor que han tenido que desempeñar desde hace
mucho los diseñadores: traducir un documento narrativo, ambiguo, monolitico y redundante a un modelo útil y no de procedimientos, para que sirva de base para deri-var la jerarquia de módulos que ejecutarán los requisitos del usuario. En otras palabras los que llevan a cabo el diseño estructurado han supuesto tradicionalmente que se les daría una especificación clásica; en consecuencia, su primera tarea, desde su punto de vista, es transformar la especificación en un paquete de diagra-mas de flujo de datos, de diccionarios de datos, de diagramas de entidad relación y de especificaciones de procesos.
Esta labor es más difícil de lo que se pudiera imaginar: históricamente se ha llevado a cabo en el vacío. En general, los diseñadores tenían poco contacto con el analista que escribía la especificación y definitivamente ¡no tenían contacto con el usuario! 
Es obvio que esta situación amerita un cambio. Al presentar el análisis estruc-turado, que es el enfoque moderno de análisis de sistemas que se maneja en este li-bro, además de extenderse con la idea de la retroalimentación entre una parte del proyecto y otra, se crea un tipo totalmente distinto de ciclo de vida del proyecto. Es-te es el ciclo de vida estructurado del proyecto que discutiremos a continuación. EL CICLO DE VIDA ESTRUCTURADO DEL PROYECTO 
Ahora que ya hemos visto los ciclos de vida del proyecto clásico y semiestruc-turado, estamos listos para examinar el ciclo de vida estructurado, que se muestra en la figure Examinaremcs brevemente las nueve actividades y los tres terminadores del ciclo de vida del proyecto, como se muestra en la figura Los terminadores son los usuarios, los administradores y el personal de operaciones; como se recordará, discutimos sus papeles en el capítulo Se trata de individuos o grupos que propor-cionan las entradas al equipo del proyecto, y son los beneficiados finales del siste-ma. Ellos interactúan con las nueve actividades que se muestran en la figura En las siguientes secciones se resume cada una de las actividades. Actividad : La encuesta 
Esta actividad también se conoce como el estudio de factibilidad o como el es-tudic inicial de negocios. Por lo común, empieza cuando el usuario solicita que una o más partes de su sistema se automaticen. Los principales objetivos de la encuesta son los siguientes: 
Identificar a los usuarios responsables y crear un "campo de actividad" inicial del sistema. Esto puede comprender la conducción de una serie de entrevistas para determinar qué usuarios estarán comprendidos en (o serán afectados por) el proyecto propuesto. Pudiera también implicar el desarrollo de un diagrama inicial de contexto, que es un diagrama de flujo de datos sencillo del tipo que se muestra en la figura , en el cual se re-presenta el sistema completo con un solo proceso. Las técnicas de encuesta se discuter en el Apéndice E. El diagrama de contexto es parte del modelo ambiental que se discutirá con mayor detalle en el capítulo Su principal propósito, como se indica aquí, es definir cuánto abarca el sistema, asícomo los diversos terminadores (personas, unidades organizacionales, otros sistemas de cómputo, etc.) con los que el sistema interactuará.
Identificar las deficiencias actuales en el ambiente del usuario. Esto en general comprenderá la lista de funciones que hacen falta o que se están Ilevando a cabo insatisfactoriamente en el sistema actual. Por ejemplo, esto pudiera incluir declaraciones como las siguientes:
* El hardware del sistema actual no es confiable y el vendedor se aca-ba de declarar en quiebra. 
El software del sistema actual no se puede mantener, y no podemos ya contratar programadores de mantenimiento dispuestos a darle mantenimiento en el lenguaje que originalmente se utilizó para desa-rrollarlo. 
El tiempo de respuesta del sistema telefónico de pedidos actual es tan malo que muchos clientes cuelgan frustrados antes de hacer su pedico. 
El sistema actual no es capaz de producir los informes requeridos pcr la modificación a los impuestos decretada el año anterior. 
El sistema actual no es capaz de recibir los informes sobre límites de crédito del departamento de contabilidad, y no puede producir los in-formes de promedio de volumen de pedidos que requiere el departa-mento de mercadotecnia. 
Establecer metas y objetivos para un sistema nuevo. Esto puede ser tam-bién una simple lista narrativa que contenga las funciones existentes que deben reimplantarse, las nuevas que necesitan añadirse y los criterios de desempeño del nuevo sistema. 
Determiner si es factible automatizar el sistema y de ser asi, sugerir esce-narios aceptables. Esto implicará algunas estimaciones bastante rudi-mentaras y aproximadas del costo y el tiempo necesarios para construir un sistema nuevo y los beneficios que se derivarán de ello: también in-volucrará dos o más escenarios (por ejemplo, el escenario con una com-putadora grande, el de procesamiento distribuido, etc.). Aunque a estas alturas la administración y los usuarios usualmente querrán una estima-cón precisa y detallada, el analista tendrá mucha suerte si logra determi-nar el tiempo, los recursos y los costos con un error menor del % en esta etapa tan temprana del proyecto. 
Preparar el esquema que se usará para guiar el resto del proyecto. Este esquema incluirá toda la información que se lista anteriormente, además de identificar al administrador responsable del proyecto. También pudiera describir los detalles del ciclo de vida que seguirá el resto del proyecto. 
En general, la encuesta ocupa sólo del al por ciento del tiempo y los re-cursos de todo el proyecto, y para los proyectos pequeños y sencillos pudiera ni si-quiera ser una actividad formal. Sin embargo, aun cuando no consuma mucho del Los cálculos de costo-beneficio se discutirán en el apéndice C.
tiempo y de los recursos del proyecto, es una actividad verdaderamente importante: al final de la encuesta, la administración pudiera decidir cancelar el proyecto si no parece atractivo desde el punto de vista de costo-beneficio. 
Como analista, usted podrá o no estar involucrado en la encuesta; pudiera ser que antes de que siquiera se haya enterado del proyecto, el usuario y los niveles apropiados de la administración ya la hayan hecho. Sin embargo, en proyectos grandes y complejos, la encuesta requiere trabajo tan detallado que a menudo el usuario solicitará la colaboración del analista lo más pronto posible. 
No discutiremos la encuesta con mayor detalle en este libro. Si llega a tener que ver con esta actividad, encontrará de utilidad los apéndices E y C. Para detalles adicionales, consulte [Dickinson, ], [Gore y Stubbe, ] y [Yourdon, . Actividad : El análisis de sistemas 
El propósito principal de la actividad de análisis es transformar sus dos entra-das -o insumos o factores principales, las políticas del usuario y el esquema del proyecto, en una especificación estructurada. Esto implica modelar el ambiente del usuario con diagramas de flujo de datos, diagramas de entidad relación, diagramas de transición de estado y demás herramientas que se presentaron en el capítulo Estas herramientas se tratan con detalle en la parte II. 
El proceso paso a paso del análisis de sistemas (es decir, las subactividades de la actividad de análisis de la figura se discute en la parte III. Como veremos, implica el desarrollo de un modelo ambiental (que se trata en el capítulo y el de-sarrollo de un modelo de comportamiento (que se discute en los capítulos y . Estos dos modelos se combinan para formar el modelo esencial (que se explica en el capítulo , que representa una descripción formal de lo que el nuevo sistema debe hacer, independientemente de la naturaleza de la tecnología que se use para cubrir los requerimientos. 
Además del modelo del sistema que describe los requerimientos cel usuario, generalmente se prepara un conjunto de presupuestos y cálculos de costos y benefi-cios más precisos y detallados al final de la actividad de análisis. Esto se discute con más detalle en el apéndice C. 
Obviamente, como analista del sistema, en esto pasará la mayor parte de su tiempo. No hay nada más que se necesite decir acerca de la actividad de análisis en este momento, ya que ese es el tema que trata todo el resto del libro. Actividad : el diseño 
La actividad de diseño se dedica a asignar porciones de la especificación (también conocida como modelo esencial) a procesadores adecuados (sean máqui-nas o humanos) y a labores apropiadas (o tareas, particiones, etc.) dentro de cada procesador. Dentro de cada labor, la actividad de diseño se dedica a la creación de una jerarquía apropiada de módulos de programas y de interfases entre ellos para implantar la especificación creada en la actividad Además, la actividad de diseño se ocupa de la transformación de modelos de datos de entidad-relación en un diseño de base de datos; véase [Inmon, ] para más detalles. 
Parte de esta actividad le interesará como analista: el desarrollo de algo cono-cico como el modelo de implantación del usuario. Este modelo describe los asuntos relacionados con la implantación que le importan al usuario al grado de que no se los quiere confia a los diseñadores y programadores. Los asuntos principales que suelen preocupar al usuario son aquellos relacionados con la especificación de la frontera humano-máquina y la especificación de la interfaz hombre-máquina. Esa frontera separa las partes del modelo esencial que llevará a cabo una persona (co-me actividad manual), de las partes que se implantarán en una o más computadoras. De manera similar, la interfaz hombre-máquina es una descripción del formato y de la secuencia ce entradas que los usuarios proporcionan a la computadora (por ejem-plo, el diseño de pantallas y el diálogo en línea entre el usuario y la computadora), además del forrato y la secuencia de salidas o productos que a computadora propcrciona al usuario. El modelo de implantación del usuario se describe en el ca-pítulo Er el capítulo se puede encontrar una introducción al proceso de diseño de sistemas. Se puede encontrar material adicional en [Yourdon y Constantine, , [Page-Jones, ], [Jackson, ], y otros. Actividad : Implantación 
Esta actividad incluye la codificación y la integración de módulos en un esque-leto progresivamente más completo del sistema final. Por eso, la actividad incluye tanto programación estructurada como implantación descendente. 
Como podrá imaginar, el analista típicamente no se verá involucrado en esta actividad, aunque hay algunos proyectos (y organizaciones) donde el análisis, el di-seño y la implantación de sistemas los hace la misma persona. Este tema se discu-te más a fondo en e capítulo Actividad : generación de pruebas de aceptación 
La especificación estructurada debe contener toda la información necesaria para definir un sistema que sea aceptable desde el punto de vista del usuario. Por eso, una vez çenerada la especificación, puede comenzar la actividad de producir un conjunto de casos de prueba de aceptación desde la especificación estructurada. 
Dado que el desarrollo de las pruebas de aceptación puede suceder al mismo tiempo cue las actividades de diseño e implantación, pudiera ser que al analista le sea asignada esta labor al término del desarrollo del modelo esencial en la actividad En el capítulo se discute con más detalle el proceso de prueba. Actividad : garantía de calidad 
La garantía de calidad también se conoce como la prueba final o la prueba de aceptación. Esta actividad requiere como entradas los datos de la prueba de acep-tación generada en la actividad y el sistema integrado producido en la actividad El analista pudiera estar involucrado con la actividad de garantía de calidad, pero por lo regular no lo está. Pueden tomar la responsabilidad uno o más miembros de la organización usuaria, o pudiera llevaria a cabo un grupo independiente de prueba o un departamento de control de calidad. Consecuentemente, no se discutirá con más detalle la función de garantía de calidad. 
Nótese, por cierto, que algunas personas le llaman a esta actividad "control de calidad" en lugar de "garantía de calidad". Sin importar la terminología, se necesita una actividad que verifique que el sistema tenga un nivel apropiado de calidad; le hemos llamado garantia de calidad en este libro. Nótese también que es importante llevar a cabo actividades de garantía de calidad en cada una de las actividades ante-riores para asegurar que se hayan realizado con un nivel apropiado de calidad. Por eso, se esperaría que esto se haga durante toda la actividad de análisis, diseño y programación para asegurar que el analista esté desarrollando especificaciones de alta calidad, que el diseñador esté produciendo diseños de alta calidad y que el pro-gramador este escribienco códigos de alta calidad. La actividad de garantía de cali-dad que se menciona aquí es simplemente la prueba final de la calidad del sistema. Actividad : descripción del procedimiento 
A lo largo de todo este libro nos preocupamos por el desarrollo de un sistema completo: no sólo de la porción automatizada, sino también de la parte que llevarán a cabo las personas. Por ello, una de las actividades importantes a realizar es la ge-neración de una descripción formal de las partes del sistema que se harán en forma manual, lo mismo que la descripción de cómo interactuarán los usuarios con la parte automatizada del nuevo sistema. El resultado de la actividad es un manual para el usuario. 
Como podrá imaginar, esta también es una actividad en la que pudiera verse involucrado como analista. Aunque no se discutirá más a fondo en este libro, podría consultar libros acerca de redacción técnica para obtener mayor información sobre la escritura de manuales para el usuario. Actividad : conversión de bases de datos 
En algunos proyectos, la conversión de bases de datos involucraba más traba-jo (y más planeación estratégica) que el desarrollo de programas de computadora para el nuevo sistema. En otros casos, pudiera no haber existido una base de datos que convertir. En el caso general, esta actividad requiere como entrada la base de datos actual del usuario, al igual que la especificación del diseño producida por me-dio de la actividad Según sea de la naturaleza del proyecto, el analista podría tener que ver con la actividad de conversión de la base de datos. Sin embargo no discutiremos esta actividad con mayor detalle en este libro. Actividad : Instalación 
La actividad final, desde luego, es la instalación; sus entradas son el manual del usuario producido en la actividad , la base de datos convertida que se creó con actividad y el sistema aceptado producido por la actividad En algunos casos, sin embargo, la instalación pudiera significar simplemente un cambio de la noche a la mañana al nuevo sistema, sin mayor alboroto; en otros casos, la instalación pudie-ra ser un proceso gradual, en el que un grupo tras otro de usuarios van recibiendo manuales y entrenamiento y comenzando a usar el nuevo sistema. Resumen del ciclo de vida del proyecto estructurado 
Es importante ver la figura como lo que es: un diagrama de flujo de datos. No es un diagrama de flujo; nada implica que toda la actividad N debe concluir antes de comenzar la actividad N + Por el contrario, la red de flujos de datos que co-nectan las actividades hace ver con claridad que pudieran estarse llevando a cabo diversas activ dades paralelamente. Debido a este aspecto no secuencial, usamos la palabra actividad en el ciclo de vida del proyecto estructurado en lugar de "fase", que es más convercional. El término fase tradicionalmente se refiere a un perio-do particular en un proyecto en el cual se estaba desarrollando una, y sólo una, acti-vidad. 
Hay otra cosa que debe recalcarse acerca del uso de un diagrama de flujo de datos para describir el ciclo de vida del proyecto: un diagrama de flujo de datos clá-sico, como el que se muestra en la figura , no muestra en forma explícita la retro-alimentación, ni el control. Prácticamente todas las actividades de la figura pueden y suelen producir información que puede llevar a modificaciones adecuadas de una o más de las actividades precedentes. De aquí que la actividad de diseño puede procucr información que acaso cambie algunas de las decisiones de costo-beneficio en la actividad de análisis; de hecho, el conocimiento que se obtiene a par-tir de la actividad ce diseño pudiera incluso llevar a revisar decisiones anteriores acerca ce la factibilidad básica del proyecto. 
Más aún, en casos extremos, ciertos eventos que pudieran darse en cualquier actividad pueden causar que todo el proyecto termine repentinamente. Las entradas de la administración se muestran sólo para la actividad de análisis pues ésta es la única que requiere datos de la administración: sin embargo, se supone, que la admi-nistración ejerce control sobre todas las actividades. En realidad, hay maneras de mostrar la retroalimentación y el control en los diagramas de flujo de datos, como se verá en el capítulo Las notaciones adicionales (para flujos de control y de procesos de control) normalmente se utilizan para modelar sistemas de tiempo real y hemos evitado su uso en este rrodelo del "sistema para construir sistemas".
En resumen, la fFigura sólo señala la o las entradas requeridas por cada actividad, y la o las salidas o productos que se generan. La secuencia de las activi-dades sólo puede suponerse en la medida en que la presencia o ausencia de datos haga posible comenzar una determinada actividad. IMPLANTACION RADICAL CONTRA IMPLANTACION DESCENDENTE CONSERVADORA 
En la sección anterior señalé que el ciclo de vida del proyecto estructurado permite que más de una actividad se lleve a cabo a la vez. Pongámoslo de otra ma-nera: en la situación más extrema, todas las actividades del ciclo de vida estruc-turado pudieran estarse realizando simultáneamente. En el otro extremo, el administrador del proyecto pudiera decidir adoptar el enfoque secuencial, que implica terminar completamente una actividad antes de emprender la siguiente. 
Es conveniente tener terminología para discutir estos extremos así como los términos medios entre ellos. El enfoque radical del ciclo de vida del proyecto estruc-turado es aquel en el que las actividades a se llevan a cabo paralelamente desde el principio del proyecto: la codificación se inicia el primer día del proyecto, y la en-cuesta y el análisis continúan hasta el último. En cambio, en el enfoque conservador del ciclo de vida del proyecto estructurado, la actividad N completa se termina antes de comenzar con la actividad N + Obviamente, ningún administrador en sus cabales adoptaría cualquiera de es-tos dos extremos. La clave para reconocer esto consiste en que los extremos radi-cal y conservador definidos anteriormente son los puntos extremos de una gama de opciones; esto se ilustra en la figura Existe un infinito número de opciones entre los extremos radical y conservador. Un administrador de proyecto pudiera decidir terminar el % de la actividad de encuesta, seguido por la terminación del % del análisis del sistema, y luego del % del diseño para poder producir un esqueleto ra-zonable de un sistema cuyos detalles pudieran posteriormente refinarse al pasar por segunda vez por el ciclo de vida entero del proyecto. O bien, el administrador pudie-ra decidir terminar todas las actividades de encuesta y de análisis, seguido por la terminación del % del diseño y el % de la implantación. Las posibilidades son interminables.
¿Cómo decide un administrador de proyecto si adoptar un enfoque radical o conservador? Básicamente, no hay respuesta; la decisión suele basarse en los si-cuientes factores: 
¿Qué tan voluble es el usuario? 
¿Bajo qué presión labora el equipo del proyecto para producir resultados tangibles e inmediatos? 
¿Bajo qué presión labora el administrador del proyecto para producir un presupuesto, programa, y estimación de personas y otros recursos? 
¿Cuáles son los peligros de cometer un error técnico importante? 
Como podrá apreciarse, ninguna de estas preguntas puede responderse clara-mente Por ejemplo, uno no puede preguntarle al usuario, en una conversación in-formal "¿Qué tan voluble andas hoy?". Por otro lado, el administrador del proyecto debiera poder juzgar la situación basándose en la observación, sobre todo si es un veterano que ha lidiado anteriormente con muchos usuarios y administradores de al-to nivel. 
Si el administrador del proyecto juzga que está tratando con un usuario voluble cuya persoralidad es tal que retrasa la toma de decisiones hasta estar seguro de que el sistema va a funcionar, entonces probablemente optaría por un enfoque más radical. Lo mismo si trata con un usuario sin experiencia, a quien le hayan creado pocos sistemas. ¿Por qué pasar años desarrollando un conjunto perfecto de especi ficaciones tan sólo para descubrir que el usuario no comprendió su significado? 
Por otro lado, si el administrador trata con un usuario veterano que está abso-lutamente seguro de lo que quiere, y si éste último trabaja en un área estable y con poca prosabilidad de cambiar radicalmente de un mes a otro, entonces puede darse el lujo de adoptar un enfoque más conservador. Desde luego, hay muchas situacio-nes intermedias: el usuario puede estar seguro de algunas de las funciones de nego-cios que deverán llevarse a cabo, pero al mismo tiempo no estar seguro del tipo de nformes administrativos que desea que el sistema le proporcione. O bien, si el usuario está familiarizado con sistemas computacionales por lotes (batch), podría no estar securo del impacto que pudiera tener en la empresa un sistema en línea. 
Además de la volubilidad, existe un segundo factor que se debe considerar: la presión a la que se está sometido para producir resultados tangibles e inmediatos. Si, debido a las políticas u otras presiones externas, el equipo que realiza el proyec to debe concluirlo forzosamente para una fecha determinada, entonces se requiere un enfocue ur tanto radical. El administrador del proyecto aún corre el riesgo de que el sistema sólo esté completo en un por ciento para la fecha límite, pero por lo menos será un esqueleto operante completo en un por ciento que puede mos trarse y tal vez incluso ponerse a producir. Eso generalmente es mejor que haber
terminado todo el análisis de sistemas, todo el diseño y toda la codificación, pero na-da de las pruebas. 
Desde luego, todos los proyectos llegan a verse apremiados a llegar a resulta-dos tangibles; la cuestión es el del apremio. Es un asunto que puede ser algo diná-mico: un proyecto que comienza holgadamente con un programa cómodo puede de repente volverse de alta prioridad y la fecha límite adelantarse seis meses o un año. Una de las ventajas de hacer el análisis, diseño, codificación e implantación del sis-tema en forma descendente es que se puede suspender una actividad en cualquier momento y dejar los detalles restantes para consideración posterior; mientras tanto, el análisis de alto nivel que se haya terminado puede usarse para comenzar el dise-ño de alto nivel, y así para los demás casos. 
Otro factor más en la administración de proyectos es el requisito siempre pre-sente en la mayoría de las organizaciones grandes de que se tienen que producir programas, estimaciones, presupuestos, etc. En algunas organizaciones, esto suele hacerse de manera bastante informal, normalmente porque los proyectos son relati-vamente pequeños y porque la administración siente que cualquier error en la esti-mación tendrá poco impacto en la organización global. En tales casos se puede adoptar un enfoque radical, aunque cualquier intento de hacer una estimación se tendrá que reducir al nivel de conjeturas viscerales. En cambio, la mayoría de los proyectos requieren estimaciones relativamente detalladas de necesidades de per-sonal, recursos computacionales, etc., y esto sólo se puede realizar tras un sondeo, análisis y diseño bastante detallados. En otras palabras, entre más detalladas y pre-cisas tengan que ser las estimaciones, más probable es que el proyecto siga un en-foque conservador. 
Finalmente, el administrador del proyecto debe considerar el peligro de come-ter un error técnico importante. Por ejemplo, suponga que toda su experiencia pasa-da en desarrollo de proyectos ha sido con una pequeña computadora de procesamiento por lotes IBM/ Ahora, de repente, está a cargo de desarrollar un sistema de multiprocesamiento en línea para administración de bases de datos dis-tribuidas, en tiempo real, que procesará millones de transacciones diarias desde terminales distribuidas en todo el mundo. En tal situación, uno de los peligros del enfoque radical es descubrir algún error importante en el diseño tras haber reali-zado una buena parte del esqueleto de alto nivel del sistema. 
Pudiera descubrir, por ejemplo, que para que su gran sistema funcione se re-quiere que un módulo de bajo nivel lleve a cabo su función en microsegundos, pero sus programadores de repente le informan que es imposible codificar un módu-lo con tanta eficiencia, ni en COBOL, ni en C, ni siquiera (juf!) en lenguaje ensam-blador. Por lo tanto, debe estar alerta al hecho de que seguir un enfoque radical requiere que sus analistas y diseñadores escojan un "tope máximo" para su sistema en etapa relativamente temprana, y que siempre existe el peligro de descubrir, ya cerca del final, que escogieron un máximo equivocado.
Sin embargo, considere otra situación: el administrador del proyecto ha decidi. do construir un sistema electrónico de proceso de datos con equipo nuevo, sistema operativo nuevo, sistema de administración de bases de datos nuevo (producido por alguien que no sea el vendedor), y un paquete de telecomunicaciones nuevo (produ cido por otra empresa más). Todos los proveedores tienen manuales brillantes e im. presionantes cue describen sus productos, pero nunca han probado la interfaz entre sus respectivos productos de hardware y software. ¿Quién sabe si siquiera funcio narán juntos? ¿Quién sabe si las funciones prometidas por un proveedor queden anuladas por los recursos del sistema que utiliza el otro? Ciertamente, en un caso como éste, el administrador del proyecto pudiera elegir un enfoque radical, para que la versión esqueleto o primaria del sistema pueda utilizarse para explorar los posi bles problemas ce interacción e interfaz entre los componentes de los diferentes proveedores. 
Si el administrador del proyecto está a cargo de un tipo familiar de sistema co-no, por ejemplo, su nonagésimo noveno sistema de nóminas, probablemente tenga pastante idea de qué tan realistas sean sus metas. Es posible que recuerde, de su proyecto anterior, qué tipo de módulos necesitará a nivel detallado, y probablemente recuerde con daridad cómo se veía la estructura de alto nivel del sistema. En tal ca-so, pudiera estar dispuesto a correr el riesgo de cometer un error dados los demás beneficios que puede traerle un enfoque radical. 
En resumer, el enfoque radical es el más adecuado para intentos apenas dis-Irazados de investigación y desarrollo, en los que nadie está muy seguro de qué es lo cue se supone que debe hacer el sistema final. Y es bueno para los casos en los que para determirada fecha algo tiene que estar ya funcionando, y en situaciones en las que la percepción del usuario respecto a lo que desea que el sistema haga esté sujeta a posibles cambios. El enfoque conservador, por otro lado, suele usarse en proyectos más grandes, en los que se invierten cantidades enormes de dinero y para los cuales se requiere un análisis y diseño muy detallados para evitar desastres sub-secuentes. Sin embargo, cada proyecto es diferente y requiere de su propia combi-nación de implantación descendente conservadora y radical. Para tratar la naturaleza individual de cada proyecto, el administrador debe estar dispuesto a mo-dificar su enfoque en mitad del camino si es necesario. EL CICLO DE VIDA DE PROTOTIPOS 
Se ha vuelto popular en los últimos años una variación del enfoque descen-dente antes discutido. En general se le conoce como el enfoque de prototipos y lo popularizaron Bernard Boar, James Martin y otros. Como lo describe Boar [Boar, ]: 
Una alternativa de enfoque para la definición de los requerimientos consiste en capturar un conjunto inicial de necesidades e implantar-las rápidamente con la intención declarada de expandirlas y refinar-las iterativamente al ir aumentando la comprensión que del sistema tiener el usuario y quien lo desarrolla. La definición del sistema se realiza mediante el descubrimiento evolutivo y gradual y no a través de la previsión omnisciente... Este tipo de enfoque se llama "de prototipos". También se le conoce como modelado del sistema o desarrollo heurístico. Ofrece una alternativa atractiva y practicable a los métodos de especificación para tratar mejor la incertidumbre, la ambigüedad y la volubilidad de los proyectos reales. 
Por muchas razones, esto suena exactamente como el enfoque descendente radical que se discutió en la sección anterior. La principal diferencia es que el enfo-que estructurado que se discute a lo largo de este libro supone que tarde o temprano se construirá un modelo en papel completo del sistema (es decir, un juego completo de diagramas de flujo de datos, de diagramas entidad-relación, de diagramas de transición de estados, de especificaciones de procesos, etc.). El modelo se comple-tará más pronto con un enfoque conservador y más tarde con uno radical, pero para el final del proyecto habrá un juego formal de documentos que deberán permanecer siempre con el sistema, a lo largo de su corrección y mantenimiento. 
El enfoque de prototipos, por otro lado, casi siempre supone que el modelo se-rá operante, es decir, una colección de programas de computadora que simularán al-gunas o todas las funciones que el usuario desea. Pero dado que se pretende que dichos programas sean sólo de modelo, también se supone que al concluirse el mo-delado, los programas se descartarán y se reemplazarán con programas REALES. Quienes hacen prototipos generalmente usan los siguientes tipos de herramientas de software: 
Un diccionario de datos integrado 
Un generador de pantallas 
Un generador de reportes no guiado por procedimientos 
Un lenguaje de programación de cuarta generación 
Un lenguaje de consultas no guiado por procedimientos 
Medios poderosos de administración de bases de datos 
El ciclo de vida de prototipos propuesto por Boar se muestra en la figura Comienza con una actividad de sondeo. similar a la que propone este libro. De esto sigue inmediatamente una determinación de si el proyecto es un buen candidato pa-ra un enfoque de prototipos. Los buenos candidatos son aquellos que tienen las si-guientes características: 
El usuario no puede o no está dispuesto a examinar modelos abstractos en papel, tales como diagramas de flujo de datos. 
El usuario no puede o no está dispuesto a articular (o "pre-especificar") sus requerimientos de ninguna forma y sólo se pueden determinar sus re-querimientos mediante un proceso de tanteo, o ensayo y error. O, como 
lo dice mi colega Bob Spurgeon, es la situación en la que el usuario dice: "No sé qué es lo que quiero, pero lo reconoceré cuando lo vea".
Se tiene la intención de que el sistema sea en línea y con operación total por la pantalla, en contraposición con los sistemas de edición, actualiza-ción y reportes operados por lotes. (Casi todas las herramientas de soft-ware de prototipos apuntan al enfoque orientado a terminales en línea y manejadas por bases de datos; existen pocas herramientas de software en el mercado para ayudar a la creación de prototipos de sistemas de procesamiento por lotes.) 
El sistema no requiere la especificación de grandes cantidades de deta-lies algorítmicos, ni de muchas especificaciones de procesos para descri-bir los algoritmos con los cuales se obtienen los resultados. Por ello, los sistemas de apoyo a decisiones, de recuperación ad hoc (a propósito) y de administración de registros son buenos candidatos para el prototipo. Los buenos candidatos suelen ser sistemas en los cuales el usuario se preocupa más por el formato y distribución de los datos de entrada y sali-da en la pantalla, y por los mensajes de error, que por los cómputos que realiza el sistema para lograrlo. 
Es importante notar que el ciclo de vida de prototipos que se muestra en la fi-gura concluye con una fase de diseño de un ciclo de vida estructurado "tradicio-nal" como los que describe este libro. Específicamente, esto significa que no se tiene la intención de que el prototipo haga las veces de un sistema operacional; la intención es tan sólo que modele los requerimientos del usuario. 
El enfoque de prototipos ciertamente tiene su mérito en muchas situaciones. En algunos casos, el administrador del proyecto tal vez quiera utilizar este enfoque como alternativa al de análisis estructurado que se presenta en este libro; en otros casos, pudiera desear utilizarlo en conjunto con la creación de modelos en papel, como los diagramas de flujo de datos. Tenga en mente lo siguiente: 
El enfoque descendente descrito en la sección anterior es otra manera de hacer un prototipo, pero en vez de usar herramientas que se pueden ob-tener en el mercado, como generadores de pantallas y lenguajes de cuar-ta generación, el equipo que realiza el proyecto utiliza el sistema mismo como su propio prototipo. Es decir, las diversas versiones de un esquele-to del sistema proveen un modelo operativo con el cual el usuario puede interactuar y darse así una idea más realista de las funciones del sistema que la que se pudiera formar a partir de un modelo en papel. 
El ciclo de vida de prototipos, como se describió anteriormente, involucra el desarrollo de un modelo funcional, que luego se descarta y se reempla-za con un sistema de producción. Existe un peligro considerable de que el usuario o el equipo que desarrolla el sistema traten de convertir al pro-totipo mismo en un sistema de producción. Esto suele resultar un desas-tre, pues el prototipo no puede trabajar eficientemente con grandes volúmenes de transacciones, y porque carece de detalles operacionales tales como recuperación de errores, auditorías, características de respal-do/reinicio, documentación para el usuario y procedimientos de conver-sión. 
Si de hecho se descarta el prototipo y se reemplaza con el sistema de producción, existe el peligro real de que pudiera concluirse el proyecto sin dejar un registro permanente de los requerimientos del usuario. Esto pro-bablemente dificulte cada vez más el mantenimiento con el paso del tiem-po (por ejemplo, diez años después de la construcción del sistema, será difícil que los programadores de mantenimiento incorporen algún cambio, pues nadie, incluyendo a los usuarios de "segunda generación" que están trabajardo actualmente con el sistema, recordará lo que se suponía en primer lugar que debía hacer). El ciclo de vida que se presenta en este li-bro se basa en la idea de que los modelos en papel desarrollados durante la actividad de análisis no sólo serán una entrada para la actividad de di-seño, sno que también se conservarán (y se modificarán según vaya sienco necesario) durante el mantenimiento. De hecho, los modelos pu-dieran sobrevivir más allá del sistema en el cual se implantaron, y pudie-ran servir como especificación para el sistema de reemplazo. RESUMEN 
El principal propósito de este capítulo fue proporcionar una visión global de los ciclos de vida ce los proyectos en general. Si examina el ciclo de vida formal de proyectos en cualquier organización de desarrollo de sistemas, debería poder distin-guir si se trata de uno clásico, semiestructurado, estructurado, o de prototipos. 
Si su proyecto sólo permite una actividad a la vez, la discusión sobre implanta-ción descendente radical y conservadora de la Sección puede haberlo perturba-do. Este fue mi propósito, y el principal objetivo de esa sección fuéehacerle pensar acerca de la posibilidad de traslapar algunas de las principales actividades en el pro-yecto de desarrolic de un sistema. Obviamente, es más difícil administrar un pro-yecto en el cual diversas actividades se llevan a cabo en paralelo, pero, hasta cierto. punto, eso sucede en todo proyecto. Aún si el administrador decide que su gente se concentrará en una actividad a la vez, de todos modos habrá varias subactividades que se llevarán a cabo en paralelo. Múltiples analistas de sistemas estarán entrevis-tando simultáneamente a múltiples usuarios; diversas piezas del producto final del análisis se encontrarán en diversas etapas de progreso a lo largo de toda la fase de análisis. Una labor del administrador es tener el suficiente control sobre dichas sub-actividades como para asegurar que se coordinen propiamente. Y en casi cualquier proyecto de proceso electrónico de datos, este tipo de actividad paralela se da tam-bien a alto nivel; es decir, a pesar de lo que pueda haber recomendado el ciclo de vi-da formal del proyecto de una organización dada, la realidad es que muchas de las prncpales actividades del proyecto sí se traslapan hasta cierto punto. No obstante, si el administrador decide insistir en una progresión de actividades estrictamente se-cuencial, aún funcionará el ciclo de vida presentado por este libro.